#include <iostream>
class T {
  int hp;
  int mp;
  inline static int count;

 public:
  int Add(int a, int b) {
    return this->hp + mp + a + b;

  }
  static int GetCount(int a, int b) {
    count++;
    return 2;
  }

};
/*
_thicall是C++中类的成员函数访问时定义的函数调用约定
(1)寄存器ecx用来存放类的指针
(2)参数由右到左入栈
(3)堆栈由被调用者负责恢复
类中的非静态成员函数都可以使用this指针,
this指针本质上来讲就是把对象的指针通过寄存器ecx传入成员函数的,
因此类中成员函数访问其成员变量时,都是通过指针+偏移的形式来访问的,不管是否
明确使用this指针

 */
/*
类的静态成员函数,本质上是采用的_cdecl约定参数由右到左入栈
由调用者恢复堆栈平衡
因为类的静态成员函数本质上就是一个普通的函数,所以根本没有传递对象的指针,因此,也就不能访问其成员变量,而类的静态成员变量本质上相当于一个全局变量,
有着固定的内存地址,与类对象并无关系,所以类的静态成员可以在类没有实例的情况下通过类:静态成员这样的形式来访问

*/


/*
我们在学习类时学习过,每个类都有一个默认构造函数,如果没有显式指定,编译器会为我们添加一个空的默认构造函数T(){}
但是我们在逆向后会发现,类T大部分的时候是没有默认构造函数的,这是因为C/C++标准委员会要求每一个类都有默认构造函数
,而一个空的构造函数实际上没有任何意义,所以某些情况下编译器会删除掉没有意义的构造函数,这是编译器优化的功劳,原则上来讲,每一个类都有默认构造函数

 */
int main() {
  T t1;
//  t1.Add(100, 200);
  t1.GetCount(100, 200);
}
