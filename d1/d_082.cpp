#include <iostream>
#include "d_082_1.h"
/*
 * 我们写好的每个源文件(.cpp,.c)将其所包含的头文件(#include <xxx.h>)合并后,称为一个转换单元;
 编译器单独的将每一个转换单元生成为对应的对象文件(.obj),对象文件包含了转换单元的机器码和转换单元的引用信息(不在转换单元中定义的对象);
最后链接器将各个转换单元的对象文件链接起来,生成我们的目标程序?
比如在对象文件A中包含了定义在其他转换单元的引用,那么就去其他转换单元的对象文件中寻找这个引用的定义来建立链接,
 如果在所有的对象文件中都找不到这个定义,那么就会生成一个链接错误
 *
 * ODR是一系列规则,而不是一个规则,程序中定义的每个对象都对应着自己的规则;
但是基本上来讲任何的变量,函数,类,枚举,模板,概念(C++20)在每个转换单元中都只允许有一个定义;
 非inline的函数或变量(C++17),在整个程序中,有且仅有一个定义;

 程序中的变量,函数,结构等都有着自己的名字,这些名字具有不同的链接属性,链接器就是根据这些链接属性来把各个对象文件链接起来的;
链接属性分为以下三种:
内部链接属性:该名称仅仅在本转换单元中有效
外部链接属性:该名称在其他的转换单元中也有效
无链接属性:该名称仅仅能够用于该名称的作用域内访问


*/
void test();
void test();
void test();
void test();//可以有很多声明
void test() {
  std::cout << "test" << std::endl;
}
/*void test (){
  std::cout << "test" << std::endl;//只能有一个定义
}*/

static int x = 250;//该名称仅仅在本转换单元中有效
const int l = 66;//该名称仅仅在本转换单元中有效
extern const int p;
static void f1() {//该名称仅仅在本转换单元中有效
  std::cout << "f1" << std::endl;
}
//inline int p3 = 600;//inline 声明变量C++17才支持
void f2();

inline void f3() {
  std::cout << "f3" << std::endl;
}
extern void ptest();
int main() {
//  std::cout << p << std::endl;
  std::cout << p3 << std::endl;//600
  std::cout << x << std::endl;//250
  f2();
  f3();//f3
  ptest();//f3
}
